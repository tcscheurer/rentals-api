// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: rentals.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const getRentalByID = `-- name: GetRentalByID :one
select rentals.id, user_id, name, type, description, sleeps, price_per_day, home_city, home_state, home_zip, home_country, vehicle_make, vehicle_model, vehicle_year, vehicle_length, created, updated, lat, lng, primary_image_url, users.id, first_name, last_name from rentals
join users on rentals.user_id = users.id
where rentals.id = $1
`

type GetRentalByIDRow struct {
	ID              int32
	UserID          sql.NullInt32
	Name            sql.NullString
	Type            sql.NullString
	Description     sql.NullString
	Sleeps          sql.NullInt32
	PricePerDay     sql.NullInt64
	HomeCity        sql.NullString
	HomeState       sql.NullString
	HomeZip         sql.NullString
	HomeCountry     sql.NullString
	VehicleMake     sql.NullString
	VehicleModel    sql.NullString
	VehicleYear     sql.NullInt32
	VehicleLength   sql.NullString
	Created         sql.NullTime
	Updated         sql.NullTime
	Lat             sql.NullFloat64
	Lng             sql.NullFloat64
	PrimaryImageUrl sql.NullString
	ID_2            int32
	FirstName       sql.NullString
	LastName        sql.NullString
}

func (q *Queries) GetRentalByID(ctx context.Context, id int32) (GetRentalByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getRentalByID, id)
	var i GetRentalByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.Sleeps,
		&i.PricePerDay,
		&i.HomeCity,
		&i.HomeState,
		&i.HomeZip,
		&i.HomeCountry,
		&i.VehicleMake,
		&i.VehicleModel,
		&i.VehicleYear,
		&i.VehicleLength,
		&i.Created,
		&i.Updated,
		&i.Lat,
		&i.Lng,
		&i.PrimaryImageUrl,
		&i.ID_2,
		&i.FirstName,
		&i.LastName,
	)
	return i, err
}

const getRentals = `-- name: GetRentals :many
select rentals.id, user_id, name, type, description, sleeps, price_per_day, home_city, home_state, home_zip, home_country, vehicle_make, vehicle_model, vehicle_year, vehicle_length, created, updated, lat, lng, primary_image_url, users.id, first_name, last_name from rentals 
join users on rentals.user_id = users.id
where

CASE 
WHEN $3::bool
THEN 
    rentals.id = ANY($4::int[]) and
    price_per_day >= $5::integer and
    price_per_day <= $6::integer
ELSE
    price_per_day >= $5::integer and
    price_per_day <= $6::integer
END

and
CASE
WHEN $7::bool
THEN
    ST_DistanceSphere(ST_MakePoint(rentals.lng,rentals.lat), ST_MakePoint($8::double precision,$9::double precision)) <= 100 * 1609.34
ELSE
    rentals.id is not null
END

order by
CASE 
WHEN $10::bool
THEN
    rentals.price_per_day
ELSE
    rentals.id
END
LIMIT $1
OFFSET $2
`

type GetRentalsParams struct {
	Limit           int32
	Offset          int32
	FilterIds       bool
	IDList          []int32
	PricePerDayLow  int32
	PricePerDayHigh int32
	FindNear        bool
	NearLng         float64
	NearLat         float64
	SortByPrice     bool
}

type GetRentalsRow struct {
	ID              int32
	UserID          sql.NullInt32
	Name            sql.NullString
	Type            sql.NullString
	Description     sql.NullString
	Sleeps          sql.NullInt32
	PricePerDay     sql.NullInt64
	HomeCity        sql.NullString
	HomeState       sql.NullString
	HomeZip         sql.NullString
	HomeCountry     sql.NullString
	VehicleMake     sql.NullString
	VehicleModel    sql.NullString
	VehicleYear     sql.NullInt32
	VehicleLength   sql.NullString
	Created         sql.NullTime
	Updated         sql.NullTime
	Lat             sql.NullFloat64
	Lng             sql.NullFloat64
	PrimaryImageUrl sql.NullString
	ID_2            int32
	FirstName       sql.NullString
	LastName        sql.NullString
}

func (q *Queries) GetRentals(ctx context.Context, arg GetRentalsParams) ([]GetRentalsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRentals,
		arg.Limit,
		arg.Offset,
		arg.FilterIds,
		pq.Array(arg.IDList),
		arg.PricePerDayLow,
		arg.PricePerDayHigh,
		arg.FindNear,
		arg.NearLng,
		arg.NearLat,
		arg.SortByPrice,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRentalsRow{}
	for rows.Next() {
		var i GetRentalsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.Sleeps,
			&i.PricePerDay,
			&i.HomeCity,
			&i.HomeState,
			&i.HomeZip,
			&i.HomeCountry,
			&i.VehicleMake,
			&i.VehicleModel,
			&i.VehicleYear,
			&i.VehicleLength,
			&i.Created,
			&i.Updated,
			&i.Lat,
			&i.Lng,
			&i.PrimaryImageUrl,
			&i.ID_2,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
